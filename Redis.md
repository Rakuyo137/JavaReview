# Redis

redis简介 :  内存缓存

**Redis** **为什么快？** 

•   (内存操作）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。

• （单线程，省去线程切换、锁竞争的开销）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 

• （NIO 的 IO 多路复用模型）使用多路 I/O 复用模型，非阻塞 IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程

###### redis过期删除策略

惰性删除 :  只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友 

好，但是可能会造成太多过期 key 没有被删除。

定期删除 :   每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis  

底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影 

响.



###### redis内存淘汰策略

Redis 提供 6 种数据淘汰策略： 

volatile  从已设置过期时间的数据集

lru  最少使用的key

ttl  将要过期的

lfu  

• **volatile-lru**（**least recently used**）：从已设置过期时间的数据集(server.db[i].expires）中挑选最近最少使用的数据淘汰 

• **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

• **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 

• **allkeys-lru**（**least recently used**）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的） 

• **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰 

• **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 

4.0 版本后增加以下两种： 

• **volatile-lfu**（**least frequently used**）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰 

• **allkeys-lfu**（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key 



###### redis 持久化机制(RDB  AOF)

RDB:  在指定的时间间隔内生成数据集的时间点**快照**  , 恢复速度快

AOF:  生成一个只进行追加操作的日志文件 



Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行**重写**： 重写后的新 AOF 文件包含了恢复当前数据集所需的**最小命令集合**。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。


###### 总结：rdb和aof的优缺点

RDB的优点

1.体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件

2.恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存

3.性能更高: 父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。

RDB的缺点

1.故障丢失: 因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。

2.耐久性差: 相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。

aof的优点

1.数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，咱们也最多丢失一秒数据

2.自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。

aof的缺点

1.性能相对较差：它的操作模式决定了它会对redis的性能有所损耗

2.体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。

3.恢复速度更慢

**redis有两种持久化方式，aof和rdb，aof相当于日志记录操作命令，rdb相当于数据的快照。安全性来讲由于aof的记录能够精确到秒级追加甚至逐条追加，而rdb只能是全量复制，aof明显高于rdb。但是从性能来讲rdb就略胜一筹，rdb是redis性能最大化的体现，它不用每秒监控是否有数据写入，当达到触发条件后就自动fork一个子进程进行全量更新，速度也很快。容灾回复方面rdb更是能够快速的恢复数据，而aof需要读取再写入，相对慢了很多。
**



###### **Redis** **的缓存雪崩、缓存穿透、缓存击穿**

**· 缓存穿透** (缓存不存在 数据库不存在 高并发 少量key)

–缓存穿透：缓存中和数据库中**都没有所查询的东西**，从而使数据库崩掉。

–解决方案：将一条数据库不存在的数据也放入缓存中这样即使数据库不存在但缓存中有，还可以使用布隆过滤器。 

**• 缓存击穿** (缓存不存在, 数据库存在 ,高并发 少量key)

–缓存击穿：缓存中没有但**数据库中有**，如果同一时间访问量过大会使数据崩掉。 

–解决方案：加分布式锁，一条数据访问数据库；将数据存储到缓存中，其他线程从缓存中拿。 

**• 缓存雪崩**  (缓存不存在 ,数据库存在 ,高并发 ,大量key )

–缓存雪崩：缓存中的数据正好在一个时间删除，当请求来时穿过缓存访问数据库。 

–解决方案：1.提前预热；2.设置随机缓存中数据的过期时间；3.做缓存备份

都可以使用限流的互斥锁 ,保障数据库的稳定



###### Redis 集群方案

分类  : 主从复制集群 

​				分片集群

主从复制集群 ,手动切换

带有哨兵的HA主从复制集群

客户端实现路由索引的分片集群

使用中间件代理层的分片集群(中间件解耦)

redis自身实现的cluster分片集群



###### redis事务是怎么实现的

MULTI  EXEC DISCARD WATCH 是redis的事务相关命令



